/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { CP_AMM_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const CREATE_POSITION_DISCRIMINATOR = new Uint8Array([
  48, 215, 197, 153, 96, 203, 180, 133,
]);

export function getCreatePositionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CREATE_POSITION_DISCRIMINATOR
  );
}

export type CreatePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountPositionNftMint extends string | AccountMeta<string> = string,
  TAccountPositionNftAccount extends string | AccountMeta<string> = string,
  TAccountPool extends string | AccountMeta<string> = string,
  TAccountPosition extends string | AccountMeta<string> = string,
  TAccountPoolAuthority extends
    | string
    | AccountMeta<string> = 'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC',
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountOwner extends string
        ? ReadonlyAccount<TAccountOwner>
        : TAccountOwner,
      TAccountPositionNftMint extends string
        ? WritableSignerAccount<TAccountPositionNftMint> &
            AccountSignerMeta<TAccountPositionNftMint>
        : TAccountPositionNftMint,
      TAccountPositionNftAccount extends string
        ? WritableAccount<TAccountPositionNftAccount>
        : TAccountPositionNftAccount,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? WritableAccount<TAccountPosition>
        : TAccountPosition,
      TAccountPoolAuthority extends string
        ? ReadonlyAccount<TAccountPoolAuthority>
        : TAccountPoolAuthority,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type CreatePositionInstructionData = {
  discriminator: ReadonlyUint8Array;
};

export type CreatePositionInstructionDataArgs = {};

export function getCreatePositionInstructionDataEncoder(): FixedSizeEncoder<CreatePositionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: CREATE_POSITION_DISCRIMINATOR })
  );
}

export function getCreatePositionInstructionDataDecoder(): FixedSizeDecoder<CreatePositionInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getCreatePositionInstructionDataCodec(): FixedSizeCodec<
  CreatePositionInstructionDataArgs,
  CreatePositionInstructionData
> {
  return combineCodec(
    getCreatePositionInstructionDataEncoder(),
    getCreatePositionInstructionDataDecoder()
  );
}

export type CreatePositionAsyncInput<
  TAccountOwner extends string = string,
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  owner: Address<TAccountOwner>;
  /** position_nft_mint */
  positionNftMint: TransactionSigner<TAccountPositionNftMint>;
  /** position nft account */
  positionNftAccount?: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position?: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  /** Address paying to create the position. Can be anyone */
  payer: TransactionSigner<TAccountPayer>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export async function getCreatePositionInstructionAsync<
  TAccountOwner extends string,
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountPayer extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: CreatePositionAsyncInput<
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  CreatePositionInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.positionNftAccount.value) {
    accounts.positionNftAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            112, 111, 115, 105, 116, 105, 111, 110, 95, 110, 102, 116, 95, 97,
            99, 99, 111, 117, 110, 116,
          ])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.positionNftMint.value)
        ),
      ],
    });
  }
  if (!accounts.position.value) {
    accounts.position.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([112, 111, 115, 105, 116, 105, 111, 110])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.positionNftMint.value)
        ),
      ],
    });
  }
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value =
      'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC' as Address<'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ])
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getCreatePositionInstructionDataEncoder().encode({}),
  } as CreatePositionInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >;

  return instruction;
}

export type CreatePositionInput<
  TAccountOwner extends string = string,
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  owner: Address<TAccountOwner>;
  /** position_nft_mint */
  positionNftMint: TransactionSigner<TAccountPositionNftMint>;
  /** position nft account */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  /** Address paying to create the position. Can be anyone */
  payer: TransactionSigner<TAccountPayer>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export function getCreatePositionInstruction<
  TAccountOwner extends string,
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountPayer extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: CreatePositionInput<
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): CreatePositionInstruction<
  TProgramAddress,
  TAccountOwner,
  TAccountPositionNftMint,
  TAccountPositionNftAccount,
  TAccountPool,
  TAccountPosition,
  TAccountPoolAuthority,
  TAccountPayer,
  TAccountTokenProgram,
  TAccountSystemProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value =
      'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC' as Address<'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getCreatePositionInstructionDataEncoder().encode({}),
  } as CreatePositionInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountPayer,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountEventAuthority,
    TAccountProgram
  >;

  return instruction;
}

export type ParsedCreatePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    owner: TAccountMetas[0];
    /** position_nft_mint */
    positionNftMint: TAccountMetas[1];
    /** position nft account */
    positionNftAccount: TAccountMetas[2];
    pool: TAccountMetas[3];
    position: TAccountMetas[4];
    poolAuthority: TAccountMetas[5];
    /** Address paying to create the position. Can be anyone */
    payer: TAccountMetas[6];
    /** Program to create NFT mint/token account and transfer for token22 account */
    tokenProgram: TAccountMetas[7];
    systemProgram: TAccountMetas[8];
    eventAuthority: TAccountMetas[9];
    program: TAccountMetas[10];
  };
  data: CreatePositionInstructionData;
};

export function parseCreatePositionInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedCreatePositionInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      pool: getNextAccount(),
      position: getNextAccount(),
      poolAuthority: getNextAccount(),
      payer: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getCreatePositionInstructionDataDecoder().decode(instruction.data),
  };
}
