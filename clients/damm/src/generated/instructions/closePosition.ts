/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { CP_AMM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([
  123, 134, 81, 0, 49, 68, 98, 98,
]);

export function getClosePositionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR
  );
}

export type ClosePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountPositionNftMint extends string | AccountMeta<string> = string,
  TAccountPositionNftAccount extends string | AccountMeta<string> = string,
  TAccountPool extends string | AccountMeta<string> = string,
  TAccountPosition extends string | AccountMeta<string> = string,
  TAccountPoolAuthority extends
    | string
    | AccountMeta<string> = 'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC',
  TAccountRentReceiver extends string | AccountMeta<string> = string,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPositionNftMint extends string
        ? WritableAccount<TAccountPositionNftMint>
        : TAccountPositionNftMint,
      TAccountPositionNftAccount extends string
        ? WritableAccount<TAccountPositionNftAccount>
        : TAccountPositionNftAccount,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? WritableAccount<TAccountPosition>
        : TAccountPosition,
      TAccountPoolAuthority extends string
        ? ReadonlyAccount<TAccountPoolAuthority>
        : TAccountPoolAuthority,
      TAccountRentReceiver extends string
        ? WritableAccount<TAccountRentReceiver>
        : TAccountRentReceiver,
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type ClosePositionInstructionData = {
  discriminator: ReadonlyUint8Array;
};

export type ClosePositionInstructionDataArgs = {};

export function getClosePositionInstructionDataEncoder(): FixedSizeEncoder<ClosePositionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })
  );
}

export function getClosePositionInstructionDataDecoder(): FixedSizeDecoder<ClosePositionInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getClosePositionInstructionDataCodec(): FixedSizeCodec<
  ClosePositionInstructionDataArgs,
  ClosePositionInstructionData
> {
  return combineCodec(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder()
  );
}

export type ClosePositionAsyncInput<
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountRentReceiver extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** position_nft_mint */
  positionNftMint: Address<TAccountPositionNftMint>;
  /** The token account for nft */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  rentReceiver: Address<TAccountRentReceiver>;
  /** Owner of position */
  owner: TransactionSigner<TAccountOwner>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export async function getClosePositionInstructionAsync<
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountRentReceiver extends string,
  TAccountOwner extends string,
  TAccountTokenProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: ClosePositionAsyncInput<
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  ClosePositionInstruction<
    TProgramAddress,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    rentReceiver: { value: input.rentReceiver ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value =
      'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC' as Address<'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ])
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.rentReceiver),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getClosePositionInstructionDataEncoder().encode({}),
  } as ClosePositionInstruction<
    TProgramAddress,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >;

  return instruction;
}

export type ClosePositionInput<
  TAccountPositionNftMint extends string = string,
  TAccountPositionNftAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPoolAuthority extends string = string,
  TAccountRentReceiver extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** position_nft_mint */
  positionNftMint: Address<TAccountPositionNftMint>;
  /** The token account for nft */
  positionNftAccount: Address<TAccountPositionNftAccount>;
  pool: Address<TAccountPool>;
  position: Address<TAccountPosition>;
  poolAuthority?: Address<TAccountPoolAuthority>;
  rentReceiver: Address<TAccountRentReceiver>;
  /** Owner of position */
  owner: TransactionSigner<TAccountOwner>;
  /** Program to create NFT mint/token account and transfer for token22 account */
  tokenProgram?: Address<TAccountTokenProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export function getClosePositionInstruction<
  TAccountPositionNftMint extends string,
  TAccountPositionNftAccount extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPoolAuthority extends string,
  TAccountRentReceiver extends string,
  TAccountOwner extends string,
  TAccountTokenProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof CP_AMM_PROGRAM_ADDRESS,
>(
  input: ClosePositionInput<
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): ClosePositionInstruction<
  TProgramAddress,
  TAccountPositionNftMint,
  TAccountPositionNftAccount,
  TAccountPool,
  TAccountPosition,
  TAccountPoolAuthority,
  TAccountRentReceiver,
  TAccountOwner,
  TAccountTokenProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CP_AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    positionNftMint: { value: input.positionNftMint ?? null, isWritable: true },
    positionNftAccount: {
      value: input.positionNftAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    poolAuthority: { value: input.poolAuthority ?? null, isWritable: false },
    rentReceiver: { value: input.rentReceiver ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.poolAuthority.value) {
    accounts.poolAuthority.value =
      'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC' as Address<'HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionNftMint),
      getAccountMeta(accounts.positionNftAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.poolAuthority),
      getAccountMeta(accounts.rentReceiver),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getClosePositionInstructionDataEncoder().encode({}),
  } as ClosePositionInstruction<
    TProgramAddress,
    TAccountPositionNftMint,
    TAccountPositionNftAccount,
    TAccountPool,
    TAccountPosition,
    TAccountPoolAuthority,
    TAccountRentReceiver,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >;

  return instruction;
}

export type ParsedClosePositionInstruction<
  TProgram extends string = typeof CP_AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** position_nft_mint */
    positionNftMint: TAccountMetas[0];
    /** The token account for nft */
    positionNftAccount: TAccountMetas[1];
    pool: TAccountMetas[2];
    position: TAccountMetas[3];
    poolAuthority: TAccountMetas[4];
    rentReceiver: TAccountMetas[5];
    /** Owner of position */
    owner: TAccountMetas[6];
    /** Program to create NFT mint/token account and transfer for token22 account */
    tokenProgram: TAccountMetas[7];
    eventAuthority: TAccountMetas[8];
    program: TAccountMetas[9];
  };
  data: ClosePositionInstructionData;
};

export function parseClosePositionInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedClosePositionInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionNftMint: getNextAccount(),
      positionNftAccount: getNextAccount(),
      pool: getNextAccount(),
      position: getNextAccount(),
      poolAuthority: getNextAccount(),
      rentReceiver: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data),
  };
}
