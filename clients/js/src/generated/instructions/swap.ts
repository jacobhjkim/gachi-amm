/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { AMM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getSwapParametersDecoder,
  getSwapParametersEncoder,
  type SwapParameters,
  type SwapParametersArgs,
} from '../types';

export const SWAP_DISCRIMINATOR = new Uint8Array([
  248, 198, 158, 145, 225, 117, 135, 200,
]);

export function getSwapDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP_DISCRIMINATOR);
}

export type SwapInstruction<
  TProgram extends string = typeof AMM_PROGRAM_ADDRESS,
  TAccountCurveAuthority extends
    | string
    | AccountMeta<string> = '8ZQvsV5qd1d2hpWawQ7VbDPd9qog1P3db3Bkf8SWQ4zr',
  TAccountConfig extends string | AccountMeta<string> = string,
  TAccountCurve extends string | AccountMeta<string> = string,
  TAccountInputTokenAccount extends string | AccountMeta<string> = string,
  TAccountOutputTokenAccount extends string | AccountMeta<string> = string,
  TAccountBaseVault extends string | AccountMeta<string> = string,
  TAccountQuoteVault extends string | AccountMeta<string> = string,
  TAccountBaseMint extends string | AccountMeta<string> = string,
  TAccountQuoteMint extends string | AccountMeta<string> = string,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountTokenBaseProgram extends string | AccountMeta<string> = string,
  TAccountTokenQuoteProgram extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountCashback extends string | AccountMeta<string> = string,
  TAccountCashbackTokenAccount extends string | AccountMeta<string> = string,
  TAccountL1ReferralCashbackTokenAccount extends
    | string
    | AccountMeta<string> = string,
  TAccountL2ReferralCashbackTokenAccount extends
    | string
    | AccountMeta<string> = string,
  TAccountL3ReferralCashbackTokenAccount extends
    | string
    | AccountMeta<string> = string,
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCurveAuthority extends string
        ? ReadonlyAccount<TAccountCurveAuthority>
        : TAccountCurveAuthority,
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountCurve extends string
        ? WritableAccount<TAccountCurve>
        : TAccountCurve,
      TAccountInputTokenAccount extends string
        ? WritableAccount<TAccountInputTokenAccount>
        : TAccountInputTokenAccount,
      TAccountOutputTokenAccount extends string
        ? WritableAccount<TAccountOutputTokenAccount>
        : TAccountOutputTokenAccount,
      TAccountBaseVault extends string
        ? WritableAccount<TAccountBaseVault>
        : TAccountBaseVault,
      TAccountQuoteVault extends string
        ? WritableAccount<TAccountQuoteVault>
        : TAccountQuoteVault,
      TAccountBaseMint extends string
        ? ReadonlyAccount<TAccountBaseMint>
        : TAccountBaseMint,
      TAccountQuoteMint extends string
        ? ReadonlyAccount<TAccountQuoteMint>
        : TAccountQuoteMint,
      TAccountPayer extends string
        ? ReadonlySignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountTokenBaseProgram extends string
        ? ReadonlyAccount<TAccountTokenBaseProgram>
        : TAccountTokenBaseProgram,
      TAccountTokenQuoteProgram extends string
        ? ReadonlyAccount<TAccountTokenQuoteProgram>
        : TAccountTokenQuoteProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountCashback extends string
        ? WritableAccount<TAccountCashback>
        : TAccountCashback,
      TAccountCashbackTokenAccount extends string
        ? WritableAccount<TAccountCashbackTokenAccount>
        : TAccountCashbackTokenAccount,
      TAccountL1ReferralCashbackTokenAccount extends string
        ? WritableAccount<TAccountL1ReferralCashbackTokenAccount>
        : TAccountL1ReferralCashbackTokenAccount,
      TAccountL2ReferralCashbackTokenAccount extends string
        ? WritableAccount<TAccountL2ReferralCashbackTokenAccount>
        : TAccountL2ReferralCashbackTokenAccount,
      TAccountL3ReferralCashbackTokenAccount extends string
        ? WritableAccount<TAccountL3ReferralCashbackTokenAccount>
        : TAccountL3ReferralCashbackTokenAccount,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type SwapInstructionData = {
  discriminator: ReadonlyUint8Array;
  params: SwapParameters;
};

export type SwapInstructionDataArgs = { params: SwapParametersArgs };

export function getSwapInstructionDataEncoder(): FixedSizeEncoder<SwapInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['params', getSwapParametersEncoder()],
    ]),
    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })
  );
}

export function getSwapInstructionDataDecoder(): FixedSizeDecoder<SwapInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['params', getSwapParametersDecoder()],
  ]);
}

export function getSwapInstructionDataCodec(): FixedSizeCodec<
  SwapInstructionDataArgs,
  SwapInstructionData
> {
  return combineCodec(
    getSwapInstructionDataEncoder(),
    getSwapInstructionDataDecoder()
  );
}

export type SwapAsyncInput<
  TAccountCurveAuthority extends string = string,
  TAccountConfig extends string = string,
  TAccountCurve extends string = string,
  TAccountInputTokenAccount extends string = string,
  TAccountOutputTokenAccount extends string = string,
  TAccountBaseVault extends string = string,
  TAccountQuoteVault extends string = string,
  TAccountBaseMint extends string = string,
  TAccountQuoteMint extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenBaseProgram extends string = string,
  TAccountTokenQuoteProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountCashback extends string = string,
  TAccountCashbackTokenAccount extends string = string,
  TAccountL1ReferralCashbackTokenAccount extends string = string,
  TAccountL2ReferralCashbackTokenAccount extends string = string,
  TAccountL3ReferralCashbackTokenAccount extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  curveAuthority?: Address<TAccountCurveAuthority>;
  /** config key */
  config: Address<TAccountConfig>;
  /** bonding curve account */
  curve: Address<TAccountCurve>;
  /** The user token account for input token */
  inputTokenAccount: Address<TAccountInputTokenAccount>;
  /** The user token account for output token */
  outputTokenAccount: Address<TAccountOutputTokenAccount>;
  /** The vault token account for base token */
  baseVault: Address<TAccountBaseVault>;
  /** The vault token account for quote token */
  quoteVault: Address<TAccountQuoteVault>;
  /** The mint of base token */
  baseMint: Address<TAccountBaseMint>;
  /** The mint of quote token */
  quoteMint: Address<TAccountQuoteMint>;
  /** The user performing the swap */
  payer: TransactionSigner<TAccountPayer>;
  /** Token base program */
  tokenBaseProgram: Address<TAccountTokenBaseProgram>;
  /** Token quote program */
  tokenQuoteProgram: Address<TAccountTokenQuoteProgram>;
  /** System program */
  systemProgram?: Address<TAccountSystemProgram>;
  /**
   * This tracks user stats and tier across all tokens
   * PDA validation is done manually in the handler
   */
  cashback?: Address<TAccountCashback>;
  /**
   * User's cashback token account for the quote token (ATA of cashback account)
   * This holds the actual cashback tokens
   */
  cashbackTokenAccount?: Address<TAccountCashbackTokenAccount>;
  /** l1 referral cashback token account for the quote token */
  l1ReferralCashbackTokenAccount?: Address<TAccountL1ReferralCashbackTokenAccount>;
  /** l2 referral cashback token account for the quote token */
  l2ReferralCashbackTokenAccount?: Address<TAccountL2ReferralCashbackTokenAccount>;
  /** l3 referral cashback token account for the quote token */
  l3ReferralCashbackTokenAccount?: Address<TAccountL3ReferralCashbackTokenAccount>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
  params: SwapInstructionDataArgs['params'];
};

export async function getSwapInstructionAsync<
  TAccountCurveAuthority extends string,
  TAccountConfig extends string,
  TAccountCurve extends string,
  TAccountInputTokenAccount extends string,
  TAccountOutputTokenAccount extends string,
  TAccountBaseVault extends string,
  TAccountQuoteVault extends string,
  TAccountBaseMint extends string,
  TAccountQuoteMint extends string,
  TAccountPayer extends string,
  TAccountTokenBaseProgram extends string,
  TAccountTokenQuoteProgram extends string,
  TAccountSystemProgram extends string,
  TAccountCashback extends string,
  TAccountCashbackTokenAccount extends string,
  TAccountL1ReferralCashbackTokenAccount extends string,
  TAccountL2ReferralCashbackTokenAccount extends string,
  TAccountL3ReferralCashbackTokenAccount extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof AMM_PROGRAM_ADDRESS,
>(
  input: SwapAsyncInput<
    TAccountCurveAuthority,
    TAccountConfig,
    TAccountCurve,
    TAccountInputTokenAccount,
    TAccountOutputTokenAccount,
    TAccountBaseVault,
    TAccountQuoteVault,
    TAccountBaseMint,
    TAccountQuoteMint,
    TAccountPayer,
    TAccountTokenBaseProgram,
    TAccountTokenQuoteProgram,
    TAccountSystemProgram,
    TAccountCashback,
    TAccountCashbackTokenAccount,
    TAccountL1ReferralCashbackTokenAccount,
    TAccountL2ReferralCashbackTokenAccount,
    TAccountL3ReferralCashbackTokenAccount,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  SwapInstruction<
    TProgramAddress,
    TAccountCurveAuthority,
    TAccountConfig,
    TAccountCurve,
    TAccountInputTokenAccount,
    TAccountOutputTokenAccount,
    TAccountBaseVault,
    TAccountQuoteVault,
    TAccountBaseMint,
    TAccountQuoteMint,
    TAccountPayer,
    TAccountTokenBaseProgram,
    TAccountTokenQuoteProgram,
    TAccountSystemProgram,
    TAccountCashback,
    TAccountCashbackTokenAccount,
    TAccountL1ReferralCashbackTokenAccount,
    TAccountL2ReferralCashbackTokenAccount,
    TAccountL3ReferralCashbackTokenAccount,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    curveAuthority: { value: input.curveAuthority ?? null, isWritable: false },
    config: { value: input.config ?? null, isWritable: false },
    curve: { value: input.curve ?? null, isWritable: true },
    inputTokenAccount: {
      value: input.inputTokenAccount ?? null,
      isWritable: true,
    },
    outputTokenAccount: {
      value: input.outputTokenAccount ?? null,
      isWritable: true,
    },
    baseVault: { value: input.baseVault ?? null, isWritable: true },
    quoteVault: { value: input.quoteVault ?? null, isWritable: true },
    baseMint: { value: input.baseMint ?? null, isWritable: false },
    quoteMint: { value: input.quoteMint ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: false },
    tokenBaseProgram: {
      value: input.tokenBaseProgram ?? null,
      isWritable: false,
    },
    tokenQuoteProgram: {
      value: input.tokenQuoteProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    cashback: { value: input.cashback ?? null, isWritable: true },
    cashbackTokenAccount: {
      value: input.cashbackTokenAccount ?? null,
      isWritable: true,
    },
    l1ReferralCashbackTokenAccount: {
      value: input.l1ReferralCashbackTokenAccount ?? null,
      isWritable: true,
    },
    l2ReferralCashbackTokenAccount: {
      value: input.l2ReferralCashbackTokenAccount ?? null,
      isWritable: true,
    },
    l3ReferralCashbackTokenAccount: {
      value: input.l3ReferralCashbackTokenAccount ?? null,
      isWritable: true,
    },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.curveAuthority.value) {
    accounts.curveAuthority.value =
      '8ZQvsV5qd1d2hpWawQ7VbDPd9qog1P3db3Bkf8SWQ4zr' as Address<'8ZQvsV5qd1d2hpWawQ7VbDPd9qog1P3db3Bkf8SWQ4zr'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ])
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.curveAuthority),
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.curve),
      getAccountMeta(accounts.inputTokenAccount),
      getAccountMeta(accounts.outputTokenAccount),
      getAccountMeta(accounts.baseVault),
      getAccountMeta(accounts.quoteVault),
      getAccountMeta(accounts.baseMint),
      getAccountMeta(accounts.quoteMint),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenBaseProgram),
      getAccountMeta(accounts.tokenQuoteProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.cashback),
      getAccountMeta(accounts.cashbackTokenAccount),
      getAccountMeta(accounts.l1ReferralCashbackTokenAccount),
      getAccountMeta(accounts.l2ReferralCashbackTokenAccount),
      getAccountMeta(accounts.l3ReferralCashbackTokenAccount),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getSwapInstructionDataEncoder().encode(
      args as SwapInstructionDataArgs
    ),
    programAddress,
  } as SwapInstruction<
    TProgramAddress,
    TAccountCurveAuthority,
    TAccountConfig,
    TAccountCurve,
    TAccountInputTokenAccount,
    TAccountOutputTokenAccount,
    TAccountBaseVault,
    TAccountQuoteVault,
    TAccountBaseMint,
    TAccountQuoteMint,
    TAccountPayer,
    TAccountTokenBaseProgram,
    TAccountTokenQuoteProgram,
    TAccountSystemProgram,
    TAccountCashback,
    TAccountCashbackTokenAccount,
    TAccountL1ReferralCashbackTokenAccount,
    TAccountL2ReferralCashbackTokenAccount,
    TAccountL3ReferralCashbackTokenAccount,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type SwapInput<
  TAccountCurveAuthority extends string = string,
  TAccountConfig extends string = string,
  TAccountCurve extends string = string,
  TAccountInputTokenAccount extends string = string,
  TAccountOutputTokenAccount extends string = string,
  TAccountBaseVault extends string = string,
  TAccountQuoteVault extends string = string,
  TAccountBaseMint extends string = string,
  TAccountQuoteMint extends string = string,
  TAccountPayer extends string = string,
  TAccountTokenBaseProgram extends string = string,
  TAccountTokenQuoteProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountCashback extends string = string,
  TAccountCashbackTokenAccount extends string = string,
  TAccountL1ReferralCashbackTokenAccount extends string = string,
  TAccountL2ReferralCashbackTokenAccount extends string = string,
  TAccountL3ReferralCashbackTokenAccount extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  curveAuthority?: Address<TAccountCurveAuthority>;
  /** config key */
  config: Address<TAccountConfig>;
  /** bonding curve account */
  curve: Address<TAccountCurve>;
  /** The user token account for input token */
  inputTokenAccount: Address<TAccountInputTokenAccount>;
  /** The user token account for output token */
  outputTokenAccount: Address<TAccountOutputTokenAccount>;
  /** The vault token account for base token */
  baseVault: Address<TAccountBaseVault>;
  /** The vault token account for quote token */
  quoteVault: Address<TAccountQuoteVault>;
  /** The mint of base token */
  baseMint: Address<TAccountBaseMint>;
  /** The mint of quote token */
  quoteMint: Address<TAccountQuoteMint>;
  /** The user performing the swap */
  payer: TransactionSigner<TAccountPayer>;
  /** Token base program */
  tokenBaseProgram: Address<TAccountTokenBaseProgram>;
  /** Token quote program */
  tokenQuoteProgram: Address<TAccountTokenQuoteProgram>;
  /** System program */
  systemProgram?: Address<TAccountSystemProgram>;
  /**
   * This tracks user stats and tier across all tokens
   * PDA validation is done manually in the handler
   */
  cashback?: Address<TAccountCashback>;
  /**
   * User's cashback token account for the quote token (ATA of cashback account)
   * This holds the actual cashback tokens
   */
  cashbackTokenAccount?: Address<TAccountCashbackTokenAccount>;
  /** l1 referral cashback token account for the quote token */
  l1ReferralCashbackTokenAccount?: Address<TAccountL1ReferralCashbackTokenAccount>;
  /** l2 referral cashback token account for the quote token */
  l2ReferralCashbackTokenAccount?: Address<TAccountL2ReferralCashbackTokenAccount>;
  /** l3 referral cashback token account for the quote token */
  l3ReferralCashbackTokenAccount?: Address<TAccountL3ReferralCashbackTokenAccount>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
  params: SwapInstructionDataArgs['params'];
};

export function getSwapInstruction<
  TAccountCurveAuthority extends string,
  TAccountConfig extends string,
  TAccountCurve extends string,
  TAccountInputTokenAccount extends string,
  TAccountOutputTokenAccount extends string,
  TAccountBaseVault extends string,
  TAccountQuoteVault extends string,
  TAccountBaseMint extends string,
  TAccountQuoteMint extends string,
  TAccountPayer extends string,
  TAccountTokenBaseProgram extends string,
  TAccountTokenQuoteProgram extends string,
  TAccountSystemProgram extends string,
  TAccountCashback extends string,
  TAccountCashbackTokenAccount extends string,
  TAccountL1ReferralCashbackTokenAccount extends string,
  TAccountL2ReferralCashbackTokenAccount extends string,
  TAccountL3ReferralCashbackTokenAccount extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof AMM_PROGRAM_ADDRESS,
>(
  input: SwapInput<
    TAccountCurveAuthority,
    TAccountConfig,
    TAccountCurve,
    TAccountInputTokenAccount,
    TAccountOutputTokenAccount,
    TAccountBaseVault,
    TAccountQuoteVault,
    TAccountBaseMint,
    TAccountQuoteMint,
    TAccountPayer,
    TAccountTokenBaseProgram,
    TAccountTokenQuoteProgram,
    TAccountSystemProgram,
    TAccountCashback,
    TAccountCashbackTokenAccount,
    TAccountL1ReferralCashbackTokenAccount,
    TAccountL2ReferralCashbackTokenAccount,
    TAccountL3ReferralCashbackTokenAccount,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): SwapInstruction<
  TProgramAddress,
  TAccountCurveAuthority,
  TAccountConfig,
  TAccountCurve,
  TAccountInputTokenAccount,
  TAccountOutputTokenAccount,
  TAccountBaseVault,
  TAccountQuoteVault,
  TAccountBaseMint,
  TAccountQuoteMint,
  TAccountPayer,
  TAccountTokenBaseProgram,
  TAccountTokenQuoteProgram,
  TAccountSystemProgram,
  TAccountCashback,
  TAccountCashbackTokenAccount,
  TAccountL1ReferralCashbackTokenAccount,
  TAccountL2ReferralCashbackTokenAccount,
  TAccountL3ReferralCashbackTokenAccount,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    curveAuthority: { value: input.curveAuthority ?? null, isWritable: false },
    config: { value: input.config ?? null, isWritable: false },
    curve: { value: input.curve ?? null, isWritable: true },
    inputTokenAccount: {
      value: input.inputTokenAccount ?? null,
      isWritable: true,
    },
    outputTokenAccount: {
      value: input.outputTokenAccount ?? null,
      isWritable: true,
    },
    baseVault: { value: input.baseVault ?? null, isWritable: true },
    quoteVault: { value: input.quoteVault ?? null, isWritable: true },
    baseMint: { value: input.baseMint ?? null, isWritable: false },
    quoteMint: { value: input.quoteMint ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: false },
    tokenBaseProgram: {
      value: input.tokenBaseProgram ?? null,
      isWritable: false,
    },
    tokenQuoteProgram: {
      value: input.tokenQuoteProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    cashback: { value: input.cashback ?? null, isWritable: true },
    cashbackTokenAccount: {
      value: input.cashbackTokenAccount ?? null,
      isWritable: true,
    },
    l1ReferralCashbackTokenAccount: {
      value: input.l1ReferralCashbackTokenAccount ?? null,
      isWritable: true,
    },
    l2ReferralCashbackTokenAccount: {
      value: input.l2ReferralCashbackTokenAccount ?? null,
      isWritable: true,
    },
    l3ReferralCashbackTokenAccount: {
      value: input.l3ReferralCashbackTokenAccount ?? null,
      isWritable: true,
    },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.curveAuthority.value) {
    accounts.curveAuthority.value =
      '8ZQvsV5qd1d2hpWawQ7VbDPd9qog1P3db3Bkf8SWQ4zr' as Address<'8ZQvsV5qd1d2hpWawQ7VbDPd9qog1P3db3Bkf8SWQ4zr'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.curveAuthority),
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.curve),
      getAccountMeta(accounts.inputTokenAccount),
      getAccountMeta(accounts.outputTokenAccount),
      getAccountMeta(accounts.baseVault),
      getAccountMeta(accounts.quoteVault),
      getAccountMeta(accounts.baseMint),
      getAccountMeta(accounts.quoteMint),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.tokenBaseProgram),
      getAccountMeta(accounts.tokenQuoteProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.cashback),
      getAccountMeta(accounts.cashbackTokenAccount),
      getAccountMeta(accounts.l1ReferralCashbackTokenAccount),
      getAccountMeta(accounts.l2ReferralCashbackTokenAccount),
      getAccountMeta(accounts.l3ReferralCashbackTokenAccount),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getSwapInstructionDataEncoder().encode(
      args as SwapInstructionDataArgs
    ),
    programAddress,
  } as SwapInstruction<
    TProgramAddress,
    TAccountCurveAuthority,
    TAccountConfig,
    TAccountCurve,
    TAccountInputTokenAccount,
    TAccountOutputTokenAccount,
    TAccountBaseVault,
    TAccountQuoteVault,
    TAccountBaseMint,
    TAccountQuoteMint,
    TAccountPayer,
    TAccountTokenBaseProgram,
    TAccountTokenQuoteProgram,
    TAccountSystemProgram,
    TAccountCashback,
    TAccountCashbackTokenAccount,
    TAccountL1ReferralCashbackTokenAccount,
    TAccountL2ReferralCashbackTokenAccount,
    TAccountL3ReferralCashbackTokenAccount,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type ParsedSwapInstruction<
  TProgram extends string = typeof AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    curveAuthority: TAccountMetas[0];
    /** config key */
    config: TAccountMetas[1];
    /** bonding curve account */
    curve: TAccountMetas[2];
    /** The user token account for input token */
    inputTokenAccount: TAccountMetas[3];
    /** The user token account for output token */
    outputTokenAccount: TAccountMetas[4];
    /** The vault token account for base token */
    baseVault: TAccountMetas[5];
    /** The vault token account for quote token */
    quoteVault: TAccountMetas[6];
    /** The mint of base token */
    baseMint: TAccountMetas[7];
    /** The mint of quote token */
    quoteMint: TAccountMetas[8];
    /** The user performing the swap */
    payer: TAccountMetas[9];
    /** Token base program */
    tokenBaseProgram: TAccountMetas[10];
    /** Token quote program */
    tokenQuoteProgram: TAccountMetas[11];
    /** System program */
    systemProgram: TAccountMetas[12];
    /**
     * This tracks user stats and tier across all tokens
     * PDA validation is done manually in the handler
     */
    cashback?: TAccountMetas[13] | undefined;
    /**
     * User's cashback token account for the quote token (ATA of cashback account)
     * This holds the actual cashback tokens
     */
    cashbackTokenAccount?: TAccountMetas[14] | undefined;
    /** l1 referral cashback token account for the quote token */
    l1ReferralCashbackTokenAccount?: TAccountMetas[15] | undefined;
    /** l2 referral cashback token account for the quote token */
    l2ReferralCashbackTokenAccount?: TAccountMetas[16] | undefined;
    /** l3 referral cashback token account for the quote token */
    l3ReferralCashbackTokenAccount?: TAccountMetas[17] | undefined;
    eventAuthority: TAccountMetas[18];
    program: TAccountMetas[19];
  };
  data: SwapInstructionData;
};

export function parseSwapInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedSwapInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 20) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === AMM_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      curveAuthority: getNextAccount(),
      config: getNextAccount(),
      curve: getNextAccount(),
      inputTokenAccount: getNextAccount(),
      outputTokenAccount: getNextAccount(),
      baseVault: getNextAccount(),
      quoteVault: getNextAccount(),
      baseMint: getNextAccount(),
      quoteMint: getNextAccount(),
      payer: getNextAccount(),
      tokenBaseProgram: getNextAccount(),
      tokenQuoteProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      cashback: getNextOptionalAccount(),
      cashbackTokenAccount: getNextOptionalAccount(),
      l1ReferralCashbackTokenAccount: getNextOptionalAccount(),
      l2ReferralCashbackTokenAccount: getNextOptionalAccount(),
      l3ReferralCashbackTokenAccount: getNextOptionalAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getSwapInstructionDataDecoder().decode(instruction.data),
  };
}
