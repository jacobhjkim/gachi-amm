/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimCashbackInstruction,
  type ParsedClaimCreatorFeeInstruction,
  type ParsedClaimProtocolFeeInstruction,
  type ParsedCreateCashbackInstruction,
  type ParsedCreateConfigInstruction,
  type ParsedCreateCurveWithSplTokenInstruction,
  type ParsedMigrateDammV2Instruction,
  type ParsedReclaimInactiveCashbackInstruction,
  type ParsedSwapInstruction,
  type ParsedUpdateCashbackTierInstruction,
} from '../instructions';

export const AMM_PROGRAM_ADDRESS =
  '4RAA1rYL3U1dFmbTTMJnu8SA1bkyJjSpWvLkZAHcjoLm' as Address<'4RAA1rYL3U1dFmbTTMJnu8SA1bkyJjSpWvLkZAHcjoLm'>;

export enum AmmAccount {
  BondingCurve,
  CashbackAccount,
  Config,
}

export function identifyAmmAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): AmmAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([23, 183, 248, 55, 96, 216, 172, 96])
      ),
      0
    )
  ) {
    return AmmAccount.BondingCurve;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([248, 209, 31, 44, 220, 186, 122, 131])
      ),
      0
    )
  ) {
    return AmmAccount.CashbackAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 12, 170, 224, 30, 250, 204, 130])
      ),
      0
    )
  ) {
    return AmmAccount.Config;
  }
  throw new Error(
    'The provided account could not be identified as a amm account.'
  );
}

export enum AmmInstruction {
  ClaimCashback,
  ClaimCreatorFee,
  ClaimProtocolFee,
  CreateCashback,
  CreateConfig,
  CreateCurveWithSplToken,
  MigrateDammV2,
  ReclaimInactiveCashback,
  Swap,
  UpdateCashbackTier,
}

export function identifyAmmInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): AmmInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([37, 58, 35, 126, 190, 53, 228, 197])
      ),
      0
    )
  ) {
    return AmmInstruction.ClaimCashback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([26, 97, 138, 203, 132, 171, 141, 252])
      ),
      0
    )
  ) {
    return AmmInstruction.ClaimCreatorFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([165, 228, 133, 48, 99, 249, 255, 33])
      ),
      0
    )
  ) {
    return AmmInstruction.ClaimProtocolFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([18, 138, 215, 206, 195, 119, 136, 54])
      ),
      0
    )
  ) {
    return AmmInstruction.CreateCashback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([201, 207, 243, 114, 75, 111, 47, 189])
      ),
      0
    )
  ) {
    return AmmInstruction.CreateConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([35, 73, 32, 72, 218, 39, 199, 228])
      ),
      0
    )
  ) {
    return AmmInstruction.CreateCurveWithSplToken;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([240, 234, 220, 49, 150, 233, 1, 60])
      ),
      0
    )
  ) {
    return AmmInstruction.MigrateDammV2;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([179, 87, 35, 82, 127, 137, 71, 171])
      ),
      0
    )
  ) {
    return AmmInstruction.ReclaimInactiveCashback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
      ),
      0
    )
  ) {
    return AmmInstruction.Swap;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([67, 163, 199, 88, 159, 167, 105, 183])
      ),
      0
    )
  ) {
    return AmmInstruction.UpdateCashbackTier;
  }
  throw new Error(
    'The provided instruction could not be identified as a amm instruction.'
  );
}

export type ParsedAmmInstruction<
  TProgram extends string = '4RAA1rYL3U1dFmbTTMJnu8SA1bkyJjSpWvLkZAHcjoLm',
> =
  | ({
      instructionType: AmmInstruction.ClaimCashback;
    } & ParsedClaimCashbackInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.ClaimCreatorFee;
    } & ParsedClaimCreatorFeeInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.ClaimProtocolFee;
    } & ParsedClaimProtocolFeeInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.CreateCashback;
    } & ParsedCreateCashbackInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.CreateConfig;
    } & ParsedCreateConfigInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.CreateCurveWithSplToken;
    } & ParsedCreateCurveWithSplTokenInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.MigrateDammV2;
    } & ParsedMigrateDammV2Instruction<TProgram>)
  | ({
      instructionType: AmmInstruction.ReclaimInactiveCashback;
    } & ParsedReclaimInactiveCashbackInstruction<TProgram>)
  | ({ instructionType: AmmInstruction.Swap } & ParsedSwapInstruction<TProgram>)
  | ({
      instructionType: AmmInstruction.UpdateCashbackTier;
    } & ParsedUpdateCashbackTierInstruction<TProgram>);
